{
  "customizationConfig" : {
    "additionalShapeConstructors" : null,
    "authPolicyActions" : {
      "actionPrefix" : null,
      "fileNamePrefix" : null,
      "skip" : true
    },
    "calculateCRC32FromCompressedData" : false,
    "convenienceTypeOverloads" : [ ],
    "customClientConfigFactory" : null,
    "customCodeTemplates" : null,
    "customErrorCodeFieldName" : null,
    "customExceptionUnmarshallerImpl" : null,
    "customFileHeader" : null,
    "customResponseMetadataClassName" : null,
    "customServiceMetadata" : null,
    "customServiceNameForRequest" : null,
    "customSignerProvider" : null,
    "deprecatedSuppressions" : [ "ClientMutationMethods", "ClientConstructors" ],
    "operationModifiers" : null,
    "operationsWithResponseStreamContentLengthValidation" : null,
    "presignersFqcn" : null,
    "renameShapes" : null,
    "requestMetrics" : null,
    "requiredParamValidationEnabled" : false,
    "sdkModeledExceptionBaseClassName" : null,
    "sendEmptyAutoConstructedListAsEmptyList" : null,
    "sendExplicitlyEmptyListsForQuery" : false,
    "serviceClientHoldInputStream" : false,
    "shapeModifiers" : null,
    "shapeSubstitutions" : null,
    "simpleMethods" : null,
    "skipInterfaceAdditions" : false,
    "skipSmokeTests" : true,
    "transformDirectory" : "transform",
    "useAutoConstructList" : false,
    "useAutoConstructMap" : false
  },
  "metadata" : {
    "apiVersion" : "2016-11-28",
    "asyncClient" : "AmazonLexRuntimeAsyncClient",
    "asyncClientBuilderClassName" : "AmazonLexRuntimeAsyncClientBuilder",
    "asyncInterface" : "AmazonLexRuntimeAsync",
    "cborProtocol" : false,
    "checksumFormat" : null,
    "contentType" : "",
    "cucumberModuleInjectorClassName" : "AmazonLexRuntimeModuleInjector",
    "defaultEndpoint" : "runtime.lex.us-east-1.amazonaws.com",
    "defaultEndpointWithoutHttpProtocol" : "runtime.lex.us-east-1.amazonaws.com",
    "defaultRegion" : null,
    "documentation" : "<p>Amazon Lex provides both build and runtime endpoints. Each endpoint provides a set of operations (API). Your application uses the runtime API to understand user utterances (user input text or voice). For example, suppose user says \"I want pizza\", your application sends this input to Amazon Lex using the runtime API. Amazon Lex recognizes that the user request is for the OrderPizza intent (one of the intents defined in the application). Then Amazon Lex engages in user conversation on behalf of the application to elicit required information (slot values, such as pizza size and crust type), and then performs fulfillment activity (that you configured when you created the application). You use the build-time API to create and manage your Amazon Lex applications. For a list of build-time operations, see the build-time API. . </p>",
    "endpointPrefix" : "runtime.lex",
    "hasApiWithStreamInput" : false,
    "ionProtocol" : false,
    "jsonProtocol" : true,
    "jsonVersion" : "1.1",
    "packageName" : "com.amazonaws.services.lexruntime",
    "packagePath" : "com/amazonaws/services/lexruntime",
    "protocol" : "rest-json",
    "protocolDefaultExceptionUmarshallerImpl" : null,
    "protocolFactory" : "com.amazonaws.protocol.json.SdkJsonProtocolFactory",
    "requestBaseFqcn" : "com.amazonaws.AmazonWebServiceRequest",
    "requiresApiKey" : false,
    "requiresIamSigners" : false,
    "serviceAbbreviation" : null,
    "serviceFullName" : "Amazon Lex Runtime Service",
    "serviceName" : "Amazon Lex Runtime Service",
    "signingName" : "lex",
    "smokeTestsPackageName" : "com.amazonaws.services.lexruntime.smoketests",
    "syncClient" : "AmazonLexRuntimeClient",
    "syncClientBuilderClassName" : "AmazonLexRuntimeClientBuilder",
    "syncInterface" : "AmazonLexRuntime",
    "uid" : "runtime.lex-2016-11-28",
    "unmarshallerClassSuffix" : "JsonUnmarshaller",
    "unmarshallerContextClassName" : "JsonUnmarshallerContext",
    "xmlProtocol" : false
  },
  "operations" : {
    "PostText" : {
      "asyncCallableType" : "java.util.concurrent.Callable<PostTextResult>",
      "asyncFutureType" : "java.util.concurrent.Future<PostTextResult>",
      "asyncHandlerType" : "com.amazonaws.handlers.AsyncHandler<PostTextRequest, PostTextResult>",
      "asyncReturnType" : "PostTextResult",
      "authenticated" : true,
      "deprecated" : false,
      "documentation" : "<p>Sends user input text to Amazon Lex at runtime. Amazon Lex uses the machine learning model that the service built for the application to interpret user input. </p> <p> In response, Amazon Lex returns the next message to convey to the user (based on the context of the user interaction) and whether to expect a user response to the message (<code>dialogState</code>). For example, consider the following response messages: </p> <ul> <li> <p>\"What pizza toppings would you like?\" – In this case, the <code>dialogState</code> would be <code>ElicitSlot</code> (that is, a user response is expected). </p> </li> <li> <p>\"Your order has been placed.\" – In this case, Amazon Lex returns one of the following <code>dialogState</code> values depending on how the intent fulfillment is configured (see <code>fulfillmentActivity</code> in <code>CreateIntent</code>): </p> <ul> <li> <p> <code>FulFilled</code> – The intent fulfillment is configured through a Lambda function. </p> </li> <li> <p> <code>ReadyForFulfilment</code> – The intent's <code>fulfillmentActivity</code> is to simply return the intent data back to the client application. </p> </li> </ul> </li> </ul>",
      "exceptions" : [ {
        "exceptionName" : "NotFoundException",
        "documentation" : "<p>Resource (such as the Amazon Lex bot or an alias) referred is not found.</p>",
        "httpStatusCode" : 404
      }, {
        "exceptionName" : "BadRequestException",
        "documentation" : "<p> Request validation failed, there is no usable message in the context, or the bot build failed. </p>",
        "httpStatusCode" : 400
      }, {
        "exceptionName" : "LimitExceededException",
        "documentation" : null,
        "httpStatusCode" : 429
      }, {
        "exceptionName" : "InternalFailureException",
        "documentation" : "<p>Internal service error. Retry the call.</p>",
        "httpStatusCode" : 500
      }, {
        "exceptionName" : "ConflictException",
        "documentation" : "<p> Two clients are using the same AWS account, Amazon Lex bot, and user ID. </p>",
        "httpStatusCode" : 409
      }, {
        "exceptionName" : "DependencyFailedException",
        "documentation" : "<p> One of the downstream dependencies, such as AWS Lambda or Amazon Polly, threw an exception. For example, if Amazon Lex does not have sufficient permissions to call a Lambda function which results in AWS Lambda throwing an exception. </p>",
        "httpStatusCode" : 424
      }, {
        "exceptionName" : "BadGatewayException",
        "documentation" : "<p>Either the Amazon Lex bot is still building, or one of the dependent services (Amazon Polly, AWS Lambda) failed with an internal service error.</p>",
        "httpStatusCode" : 502
      }, {
        "exceptionName" : "LoopDetectedException",
        "documentation" : "<p>Lambda fulfilment function returned <code>DelegateDialogAction</code> to Amazon Lex without changing any slot values. </p>",
        "httpStatusCode" : 508
      } ],
      "hasBlobMemberAsPayload" : false,
      "input" : {
        "variableDeclarationType" : "PostTextRequest",
        "variableName" : "postTextRequest",
        "variableType" : "PostTextRequest",
        "documentation" : "",
        "simpleType" : "PostTextRequest",
        "variableSetterType" : "PostTextRequest"
      },
      "inputStreamPropertyName" : null,
      "methodName" : "postText",
      "operationName" : "PostText",
      "returnType" : {
        "returnType" : "PostTextResult",
        "documentation" : null
      },
      "syncReturnType" : "PostTextResult"
    }
  },
  "shapes" : {
    "BadGatewayException" : {
      "c2jName" : "BadGatewayException",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p>Either the Amazon Lex bot is still building, or one of the dependent services (Amazon Polly, AWS Lambda) failed with an internal service error.</p>",
      "enums" : null,
      "errorCode" : "BadGatewayException",
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ ],
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "BadGatewayException",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "BadGatewayException",
        "variableName" : "badGatewayException",
        "variableType" : "BadGatewayException",
        "documentation" : null,
        "simpleType" : "BadGatewayException",
        "variableSetterType" : "BadGatewayException"
      },
      "wrapper" : false
    },
    "BadRequestException" : {
      "c2jName" : "BadRequestException",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p> Request validation failed, there is no usable message in the context, or the bot build failed. </p>",
      "enums" : null,
      "errorCode" : "BadRequestException",
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ ],
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "BadRequestException",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "BadRequestException",
        "variableName" : "badRequestException",
        "variableType" : "BadRequestException",
        "documentation" : null,
        "simpleType" : "BadRequestException",
        "variableSetterType" : "BadRequestException"
      },
      "wrapper" : false
    },
    "Button" : {
      "c2jName" : "Button",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p>Represents an option to be shown on the client platform (Facebook, Slack, etc.)</p>",
      "enums" : null,
      "errorCode" : null,
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ {
        "c2jName" : "text",
        "c2jShape" : "ButtonTextStringWithLength",
        "deprecated" : false,
        "documentation" : "<p>Text visible to the user on the button.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Text visible to the user on the button.</p>\n@param text Text visible to the user on the button.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withText",
        "getterDocumentation" : "/**<p>Text visible to the user on the button.</p>\n@return Text visible to the user on the button.*/",
        "getterMethodName" : "getText",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "text",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "text",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "Text",
        "setterDocumentation" : "/**<p>Text visible to the user on the button.</p>\n@param text Text visible to the user on the button.*/",
        "setterMethodName" : "setText",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "text",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Text visible to the user on the button.</p>\n@param text Text visible to the user on the button.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "text",
          "variableType" : "String",
          "documentation" : "<p>Text visible to the user on the button.</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "value",
        "c2jShape" : "ButtonValueStringWithLength",
        "deprecated" : false,
        "documentation" : "<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>\n@param value Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withValue",
        "getterDocumentation" : "/**<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>\n@return Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".*/",
        "getterMethodName" : "getValue",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "value",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "value",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "Value",
        "setterDocumentation" : "/**<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>\n@param value Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".*/",
        "setterMethodName" : "setValue",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "value",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>\n@param value Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "value",
          "variableType" : "String",
          "documentation" : "<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      } ],
      "membersAsMap" : {
        "Text" : {
          "c2jName" : "text",
          "c2jShape" : "ButtonTextStringWithLength",
          "deprecated" : false,
          "documentation" : "<p>Text visible to the user on the button.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Text visible to the user on the button.</p>\n@param text Text visible to the user on the button.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withText",
          "getterDocumentation" : "/**<p>Text visible to the user on the button.</p>\n@return Text visible to the user on the button.*/",
          "getterMethodName" : "getText",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "text",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "text",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "Text",
          "setterDocumentation" : "/**<p>Text visible to the user on the button.</p>\n@param text Text visible to the user on the button.*/",
          "setterMethodName" : "setText",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "text",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Text visible to the user on the button.</p>\n@param text Text visible to the user on the button.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "text",
            "variableType" : "String",
            "documentation" : "<p>Text visible to the user on the button.</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "Value" : {
          "c2jName" : "value",
          "c2jShape" : "ButtonValueStringWithLength",
          "deprecated" : false,
          "documentation" : "<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>\n@param value Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withValue",
          "getterDocumentation" : "/**<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>\n@return Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".*/",
          "getterMethodName" : "getValue",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "value",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "value",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "Value",
          "setterDocumentation" : "/**<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>\n@param value Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".*/",
          "setterMethodName" : "setValue",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "value",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>\n@param value Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "value",
            "variableType" : "String",
            "documentation" : "<p>Value sent to Amazon Lex when user clicks the button. For example, consider button text \"NYC\". When the user clicks the button, the value sent can be \"New York City\".</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        }
      },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : [ "text", "value" ],
      "shapeName" : "Button",
      "unmarshaller" : {
        "flattened" : false,
        "resultWrapper" : null
      },
      "variable" : {
        "variableDeclarationType" : "Button",
        "variableName" : "button",
        "variableType" : "Button",
        "documentation" : null,
        "simpleType" : "Button",
        "variableSetterType" : "Button"
      },
      "wrapper" : false
    },
    "ConflictException" : {
      "c2jName" : "ConflictException",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p> Two clients are using the same AWS account, Amazon Lex bot, and user ID. </p>",
      "enums" : null,
      "errorCode" : "ConflictException",
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ ],
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "ConflictException",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "ConflictException",
        "variableName" : "conflictException",
        "variableType" : "ConflictException",
        "documentation" : null,
        "simpleType" : "ConflictException",
        "variableSetterType" : "ConflictException"
      },
      "wrapper" : false
    },
    "ContentType" : {
      "c2jName" : "ContentType",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "",
      "enums" : [ {
        "name" : "ApplicationvndAmazonawsCardGeneric",
        "value" : "application/vnd.amazonaws.card.generic"
      } ],
      "errorCode" : null,
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : null,
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "ContentType",
      "unmarshaller" : {
        "flattened" : false,
        "resultWrapper" : null
      },
      "variable" : {
        "variableDeclarationType" : "ContentType",
        "variableName" : "contentType",
        "variableType" : "ContentType",
        "documentation" : null,
        "simpleType" : "ContentType",
        "variableSetterType" : "ContentType"
      },
      "wrapper" : false
    },
    "DependencyFailedException" : {
      "c2jName" : "DependencyFailedException",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p> One of the downstream dependencies, such as AWS Lambda or Amazon Polly, threw an exception. For example, if Amazon Lex does not have sufficient permissions to call a Lambda function which results in AWS Lambda throwing an exception. </p>",
      "enums" : null,
      "errorCode" : "DependencyFailedException",
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ ],
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "DependencyFailedException",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "DependencyFailedException",
        "variableName" : "dependencyFailedException",
        "variableType" : "DependencyFailedException",
        "documentation" : null,
        "simpleType" : "DependencyFailedException",
        "variableSetterType" : "DependencyFailedException"
      },
      "wrapper" : false
    },
    "DialogState" : {
      "c2jName" : "DialogState",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "",
      "enums" : [ {
        "name" : "ElicitIntent",
        "value" : "ElicitIntent"
      }, {
        "name" : "ConfirmIntent",
        "value" : "ConfirmIntent"
      }, {
        "name" : "ElicitSlot",
        "value" : "ElicitSlot"
      }, {
        "name" : "Fulfilled",
        "value" : "Fulfilled"
      }, {
        "name" : "ReadyForFulfillment",
        "value" : "ReadyForFulfillment"
      }, {
        "name" : "Failed",
        "value" : "Failed"
      } ],
      "errorCode" : null,
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : null,
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "DialogState",
      "unmarshaller" : {
        "flattened" : false,
        "resultWrapper" : null
      },
      "variable" : {
        "variableDeclarationType" : "DialogState",
        "variableName" : "dialogState",
        "variableType" : "DialogState",
        "documentation" : null,
        "simpleType" : "DialogState",
        "variableSetterType" : "DialogState"
      },
      "wrapper" : false
    },
    "GenericAttachment" : {
      "c2jName" : "GenericAttachment",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p>Represents an option rendered to the user when a prompt is shown. It could be an image, a button, a link, or text. </p>",
      "enums" : null,
      "errorCode" : null,
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ {
        "c2jName" : "title",
        "c2jShape" : "StringWithLength",
        "deprecated" : false,
        "documentation" : "<p>Title of the option.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Title of the option.</p>\n@param title Title of the option.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withTitle",
        "getterDocumentation" : "/**<p>Title of the option.</p>\n@return Title of the option.*/",
        "getterMethodName" : "getTitle",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "title",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "title",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "Title",
        "setterDocumentation" : "/**<p>Title of the option.</p>\n@param title Title of the option.*/",
        "setterMethodName" : "setTitle",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "title",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Title of the option.</p>\n@param title Title of the option.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "title",
          "variableType" : "String",
          "documentation" : "<p>Title of the option.</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "subTitle",
        "c2jShape" : "StringWithLength",
        "deprecated" : false,
        "documentation" : "<p>Subtitle shown below the title.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Subtitle shown below the title.</p>\n@param subTitle Subtitle shown below the title.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withSubTitle",
        "getterDocumentation" : "/**<p>Subtitle shown below the title.</p>\n@return Subtitle shown below the title.*/",
        "getterMethodName" : "getSubTitle",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "subTitle",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "subTitle",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "SubTitle",
        "setterDocumentation" : "/**<p>Subtitle shown below the title.</p>\n@param subTitle Subtitle shown below the title.*/",
        "setterMethodName" : "setSubTitle",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "subTitle",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Subtitle shown below the title.</p>\n@param subTitle Subtitle shown below the title.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "subTitle",
          "variableType" : "String",
          "documentation" : "<p>Subtitle shown below the title.</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "attachmentLinkUrl",
        "c2jShape" : "StringUrlWithLength",
        "deprecated" : false,
        "documentation" : "",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**\n@param attachmentLinkUrl \n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withAttachmentLinkUrl",
        "getterDocumentation" : "/**\n@return */",
        "getterMethodName" : "getAttachmentLinkUrl",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "attachmentLinkUrl",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "attachmentLinkUrl",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "AttachmentLinkUrl",
        "setterDocumentation" : "/**\n@param attachmentLinkUrl */",
        "setterMethodName" : "setAttachmentLinkUrl",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "attachmentLinkUrl",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**\n@param attachmentLinkUrl \n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "attachmentLinkUrl",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "imageUrl",
        "c2jShape" : "StringUrlWithLength",
        "deprecated" : false,
        "documentation" : "<p>URL of an image that is displayed to the user.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>URL of an image that is displayed to the user.</p>\n@param imageUrl URL of an image that is displayed to the user.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withImageUrl",
        "getterDocumentation" : "/**<p>URL of an image that is displayed to the user.</p>\n@return URL of an image that is displayed to the user.*/",
        "getterMethodName" : "getImageUrl",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "imageUrl",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "imageUrl",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "ImageUrl",
        "setterDocumentation" : "/**<p>URL of an image that is displayed to the user.</p>\n@param imageUrl URL of an image that is displayed to the user.*/",
        "setterMethodName" : "setImageUrl",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "imageUrl",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>URL of an image that is displayed to the user.</p>\n@param imageUrl URL of an image that is displayed to the user.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "imageUrl",
          "variableType" : "String",
          "documentation" : "<p>URL of an image that is displayed to the user.</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "buttons",
        "c2jShape" : "listOfButtons",
        "deprecated" : false,
        "documentation" : "<p>List of options to show to the user.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>List of options to show to the user.</p>\n@param buttons List of options to show to the user.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withButtons",
        "getterDocumentation" : "/**<p>List of options to show to the user.</p>\n@return List of options to show to the user.*/",
        "getterMethodName" : "getButtons",
        "getterModel" : {
          "returnType" : "java.util.List<Button>",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "buttons",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "buttons",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : true,
        "listModel" : {
          "implType" : "java.util.ArrayList",
          "interfaceType" : "java.util.List",
          "listMemberModel" : {
            "c2jName" : "member",
            "c2jShape" : "Button",
            "deprecated" : false,
            "documentation" : "",
            "enumType" : null,
            "fluentSetterDocumentation" : "/**\n@param member \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "fluentSetterMethodName" : "withMember",
            "getterDocumentation" : "/**\n@return */",
            "getterMethodName" : "getMember",
            "getterModel" : {
              "returnType" : "Button",
              "documentation" : null
            },
            "http" : {
              "additionalMarshallingPath" : null,
              "additionalUnmarshallingPath" : null,
              "flattened" : false,
              "greedy" : false,
              "header" : false,
              "isPayload" : false,
              "isStreaming" : false,
              "location" : null,
              "marshallLocation" : "PAYLOAD",
              "marshallLocationName" : "member",
              "queryString" : false,
              "statusCode" : false,
              "unmarshallLocationName" : "member",
              "uri" : false
            },
            "idempotencyToken" : false,
            "isBinary" : false,
            "list" : false,
            "listModel" : null,
            "map" : false,
            "mapModel" : null,
            "marshallingTargetClass" : "StructuredPojo",
            "marshallingType" : "STRUCTURED",
            "name" : "Member",
            "setterDocumentation" : "/**\n@param member */",
            "setterMethodName" : "setMember",
            "setterModel" : {
              "variableDeclarationType" : "Button",
              "variableName" : "member",
              "variableType" : "Button",
              "documentation" : "",
              "simpleType" : "Button",
              "variableSetterType" : "Button"
            },
            "simple" : false,
            "varargSetterDocumentation" : "/**\n@param member \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "variable" : {
              "variableDeclarationType" : "Button",
              "variableName" : "member",
              "variableType" : "Button",
              "documentation" : "",
              "simpleType" : "Button",
              "variableSetterType" : "Button"
            },
            "xmlNameSpaceUri" : null
          },
          "memberLocationName" : null,
          "memberType" : "Button",
          "map" : false,
          "marshallNonAutoConstructedEmptyLists" : false,
          "memberAdditionalMarshallingPath" : null,
          "memberAdditionalUnmarshallingPath" : null,
          "sendEmptyQueryString" : false,
          "simple" : false,
          "simpleType" : "Button",
          "templateImplType" : "java.util.ArrayList<Button>",
          "templateType" : "java.util.List<Button>"
        },
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "List",
        "marshallingType" : "LIST",
        "name" : "Buttons",
        "setterDocumentation" : "/**<p>List of options to show to the user.</p>\n@param buttons List of options to show to the user.*/",
        "setterMethodName" : "setButtons",
        "setterModel" : {
          "variableDeclarationType" : "java.util.List<Button>",
          "variableName" : "buttons",
          "variableType" : "java.util.List<Button>",
          "documentation" : "",
          "simpleType" : "List<Button>",
          "variableSetterType" : "java.util.Collection<Button>"
        },
        "simple" : false,
        "varargSetterDocumentation" : "/**<p>List of options to show to the user.</p>\n<p><b>NOTE:</b> This method appends the values to the existing list (if any). Use {@link #setButtons(java.util.Collection)} or {@link #withButtons(java.util.Collection)} if you want to override the existing values.</p>\n@param buttons List of options to show to the user.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "java.util.List<Button>",
          "variableName" : "buttons",
          "variableType" : "java.util.List<Button>",
          "documentation" : "<p>List of options to show to the user.</p>",
          "simpleType" : "List<Button>",
          "variableSetterType" : "java.util.Collection<Button>"
        },
        "xmlNameSpaceUri" : null
      } ],
      "membersAsMap" : {
        "AttachmentLinkUrl" : {
          "c2jName" : "attachmentLinkUrl",
          "c2jShape" : "StringUrlWithLength",
          "deprecated" : false,
          "documentation" : "",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**\n@param attachmentLinkUrl \n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withAttachmentLinkUrl",
          "getterDocumentation" : "/**\n@return */",
          "getterMethodName" : "getAttachmentLinkUrl",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "attachmentLinkUrl",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "attachmentLinkUrl",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "AttachmentLinkUrl",
          "setterDocumentation" : "/**\n@param attachmentLinkUrl */",
          "setterMethodName" : "setAttachmentLinkUrl",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "attachmentLinkUrl",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**\n@param attachmentLinkUrl \n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "attachmentLinkUrl",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "Buttons" : {
          "c2jName" : "buttons",
          "c2jShape" : "listOfButtons",
          "deprecated" : false,
          "documentation" : "<p>List of options to show to the user.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>List of options to show to the user.</p>\n@param buttons List of options to show to the user.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withButtons",
          "getterDocumentation" : "/**<p>List of options to show to the user.</p>\n@return List of options to show to the user.*/",
          "getterMethodName" : "getButtons",
          "getterModel" : {
            "returnType" : "java.util.List<Button>",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "buttons",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "buttons",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : true,
          "listModel" : {
            "implType" : "java.util.ArrayList",
            "interfaceType" : "java.util.List",
            "listMemberModel" : {
              "c2jName" : "member",
              "c2jShape" : "Button",
              "deprecated" : false,
              "documentation" : "",
              "enumType" : null,
              "fluentSetterDocumentation" : "/**\n@param member \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "fluentSetterMethodName" : "withMember",
              "getterDocumentation" : "/**\n@return */",
              "getterMethodName" : "getMember",
              "getterModel" : {
                "returnType" : "Button",
                "documentation" : null
              },
              "http" : {
                "additionalMarshallingPath" : null,
                "additionalUnmarshallingPath" : null,
                "flattened" : false,
                "greedy" : false,
                "header" : false,
                "isPayload" : false,
                "isStreaming" : false,
                "location" : null,
                "marshallLocation" : "PAYLOAD",
                "marshallLocationName" : "member",
                "queryString" : false,
                "statusCode" : false,
                "unmarshallLocationName" : "member",
                "uri" : false
              },
              "idempotencyToken" : false,
              "isBinary" : false,
              "list" : false,
              "listModel" : null,
              "map" : false,
              "mapModel" : null,
              "marshallingTargetClass" : "StructuredPojo",
              "marshallingType" : "STRUCTURED",
              "name" : "Member",
              "setterDocumentation" : "/**\n@param member */",
              "setterMethodName" : "setMember",
              "setterModel" : {
                "variableDeclarationType" : "Button",
                "variableName" : "member",
                "variableType" : "Button",
                "documentation" : "",
                "simpleType" : "Button",
                "variableSetterType" : "Button"
              },
              "simple" : false,
              "varargSetterDocumentation" : "/**\n@param member \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "variable" : {
                "variableDeclarationType" : "Button",
                "variableName" : "member",
                "variableType" : "Button",
                "documentation" : "",
                "simpleType" : "Button",
                "variableSetterType" : "Button"
              },
              "xmlNameSpaceUri" : null
            },
            "memberLocationName" : null,
            "memberType" : "Button",
            "map" : false,
            "marshallNonAutoConstructedEmptyLists" : false,
            "memberAdditionalMarshallingPath" : null,
            "memberAdditionalUnmarshallingPath" : null,
            "sendEmptyQueryString" : false,
            "simple" : false,
            "simpleType" : "Button",
            "templateImplType" : "java.util.ArrayList<Button>",
            "templateType" : "java.util.List<Button>"
          },
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "List",
          "marshallingType" : "LIST",
          "name" : "Buttons",
          "setterDocumentation" : "/**<p>List of options to show to the user.</p>\n@param buttons List of options to show to the user.*/",
          "setterMethodName" : "setButtons",
          "setterModel" : {
            "variableDeclarationType" : "java.util.List<Button>",
            "variableName" : "buttons",
            "variableType" : "java.util.List<Button>",
            "documentation" : "",
            "simpleType" : "List<Button>",
            "variableSetterType" : "java.util.Collection<Button>"
          },
          "simple" : false,
          "varargSetterDocumentation" : "/**<p>List of options to show to the user.</p>\n<p><b>NOTE:</b> This method appends the values to the existing list (if any). Use {@link #setButtons(java.util.Collection)} or {@link #withButtons(java.util.Collection)} if you want to override the existing values.</p>\n@param buttons List of options to show to the user.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "java.util.List<Button>",
            "variableName" : "buttons",
            "variableType" : "java.util.List<Button>",
            "documentation" : "<p>List of options to show to the user.</p>",
            "simpleType" : "List<Button>",
            "variableSetterType" : "java.util.Collection<Button>"
          },
          "xmlNameSpaceUri" : null
        },
        "ImageUrl" : {
          "c2jName" : "imageUrl",
          "c2jShape" : "StringUrlWithLength",
          "deprecated" : false,
          "documentation" : "<p>URL of an image that is displayed to the user.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>URL of an image that is displayed to the user.</p>\n@param imageUrl URL of an image that is displayed to the user.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withImageUrl",
          "getterDocumentation" : "/**<p>URL of an image that is displayed to the user.</p>\n@return URL of an image that is displayed to the user.*/",
          "getterMethodName" : "getImageUrl",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "imageUrl",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "imageUrl",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "ImageUrl",
          "setterDocumentation" : "/**<p>URL of an image that is displayed to the user.</p>\n@param imageUrl URL of an image that is displayed to the user.*/",
          "setterMethodName" : "setImageUrl",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "imageUrl",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>URL of an image that is displayed to the user.</p>\n@param imageUrl URL of an image that is displayed to the user.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "imageUrl",
            "variableType" : "String",
            "documentation" : "<p>URL of an image that is displayed to the user.</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "SubTitle" : {
          "c2jName" : "subTitle",
          "c2jShape" : "StringWithLength",
          "deprecated" : false,
          "documentation" : "<p>Subtitle shown below the title.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Subtitle shown below the title.</p>\n@param subTitle Subtitle shown below the title.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withSubTitle",
          "getterDocumentation" : "/**<p>Subtitle shown below the title.</p>\n@return Subtitle shown below the title.*/",
          "getterMethodName" : "getSubTitle",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "subTitle",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "subTitle",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "SubTitle",
          "setterDocumentation" : "/**<p>Subtitle shown below the title.</p>\n@param subTitle Subtitle shown below the title.*/",
          "setterMethodName" : "setSubTitle",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "subTitle",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Subtitle shown below the title.</p>\n@param subTitle Subtitle shown below the title.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "subTitle",
            "variableType" : "String",
            "documentation" : "<p>Subtitle shown below the title.</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "Title" : {
          "c2jName" : "title",
          "c2jShape" : "StringWithLength",
          "deprecated" : false,
          "documentation" : "<p>Title of the option.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Title of the option.</p>\n@param title Title of the option.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withTitle",
          "getterDocumentation" : "/**<p>Title of the option.</p>\n@return Title of the option.*/",
          "getterMethodName" : "getTitle",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "title",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "title",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "Title",
          "setterDocumentation" : "/**<p>Title of the option.</p>\n@param title Title of the option.*/",
          "setterMethodName" : "setTitle",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "title",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Title of the option.</p>\n@param title Title of the option.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "title",
            "variableType" : "String",
            "documentation" : "<p>Title of the option.</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        }
      },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "GenericAttachment",
      "unmarshaller" : {
        "flattened" : false,
        "resultWrapper" : null
      },
      "variable" : {
        "variableDeclarationType" : "GenericAttachment",
        "variableName" : "genericAttachment",
        "variableType" : "GenericAttachment",
        "documentation" : null,
        "simpleType" : "GenericAttachment",
        "variableSetterType" : "GenericAttachment"
      },
      "wrapper" : false
    },
    "InternalFailureException" : {
      "c2jName" : "InternalFailureException",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p>Internal service error. Retry the call.</p>",
      "enums" : null,
      "errorCode" : "InternalFailureException",
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ ],
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "InternalFailureException",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "InternalFailureException",
        "variableName" : "internalFailureException",
        "variableType" : "InternalFailureException",
        "documentation" : null,
        "simpleType" : "InternalFailureException",
        "variableSetterType" : "InternalFailureException"
      },
      "wrapper" : false
    },
    "LimitExceededException" : {
      "c2jName" : "LimitExceededException",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "",
      "enums" : null,
      "errorCode" : "LimitExceededException",
      "hasHeaderMember" : true,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ {
        "c2jName" : "retryAfterSeconds",
        "c2jShape" : "String",
        "deprecated" : false,
        "documentation" : "",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**\n@param retryAfterSeconds \n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withRetryAfterSeconds",
        "getterDocumentation" : "/**\n@return */",
        "getterMethodName" : "getRetryAfterSeconds",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : true,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : "header",
          "marshallLocation" : "HEADER",
          "marshallLocationName" : "Retry-After",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "Retry-After",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "RetryAfterSeconds",
        "setterDocumentation" : "/**\n@param retryAfterSeconds */",
        "setterMethodName" : "setRetryAfterSeconds",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "retryAfterSeconds",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**\n@param retryAfterSeconds \n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "retryAfterSeconds",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      } ],
      "membersAsMap" : {
        "RetryAfterSeconds" : {
          "c2jName" : "retryAfterSeconds",
          "c2jShape" : "String",
          "deprecated" : false,
          "documentation" : "",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**\n@param retryAfterSeconds \n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withRetryAfterSeconds",
          "getterDocumentation" : "/**\n@return */",
          "getterMethodName" : "getRetryAfterSeconds",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : true,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : "header",
            "marshallLocation" : "HEADER",
            "marshallLocationName" : "Retry-After",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "Retry-After",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "RetryAfterSeconds",
          "setterDocumentation" : "/**\n@param retryAfterSeconds */",
          "setterMethodName" : "setRetryAfterSeconds",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "retryAfterSeconds",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**\n@param retryAfterSeconds \n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "retryAfterSeconds",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        }
      },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "LimitExceededException",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "LimitExceededException",
        "variableName" : "limitExceededException",
        "variableType" : "LimitExceededException",
        "documentation" : null,
        "simpleType" : "LimitExceededException",
        "variableSetterType" : "LimitExceededException"
      },
      "wrapper" : false
    },
    "LoopDetectedException" : {
      "c2jName" : "LoopDetectedException",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p>Lambda fulfilment function returned <code>DelegateDialogAction</code> to Amazon Lex without changing any slot values. </p>",
      "enums" : null,
      "errorCode" : "LoopDetectedException",
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ ],
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "LoopDetectedException",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "LoopDetectedException",
        "variableName" : "loopDetectedException",
        "variableType" : "LoopDetectedException",
        "documentation" : null,
        "simpleType" : "LoopDetectedException",
        "variableSetterType" : "LoopDetectedException"
      },
      "wrapper" : false
    },
    "NotFoundException" : {
      "c2jName" : "NotFoundException",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p>Resource (such as the Amazon Lex bot or an alias) referred is not found.</p>",
      "enums" : null,
      "errorCode" : "NotFoundException",
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ ],
      "membersAsMap" : { },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "NotFoundException",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "NotFoundException",
        "variableName" : "notFoundException",
        "variableType" : "NotFoundException",
        "documentation" : null,
        "simpleType" : "NotFoundException",
        "variableSetterType" : "NotFoundException"
      },
      "wrapper" : false
    },
    "PostTextRequest" : {
      "c2jName" : "PostTextRequest",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "",
      "enums" : null,
      "errorCode" : null,
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : {
        "action" : "PostText",
        "locationName" : null,
        "requestUri" : "/bot/{botName}/alias/{botAlias}/user/{userId}/text",
        "target" : null,
        "verb" : "POST",
        "xmlNameSpaceUri" : null
      },
      "members" : [ {
        "c2jName" : "botName",
        "c2jShape" : "BotName",
        "deprecated" : false,
        "documentation" : "<p>Name of the Amazon Lex bot.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Name of the Amazon Lex bot.</p>\n@param botName Name of the Amazon Lex bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withBotName",
        "getterDocumentation" : "/**<p>Name of the Amazon Lex bot.</p>\n@return Name of the Amazon Lex bot.*/",
        "getterMethodName" : "getBotName",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : "uri",
          "marshallLocation" : "PATH",
          "marshallLocationName" : "botName",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "botName",
          "uri" : true
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "BotName",
        "setterDocumentation" : "/**<p>Name of the Amazon Lex bot.</p>\n@param botName Name of the Amazon Lex bot.*/",
        "setterMethodName" : "setBotName",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "botName",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Name of the Amazon Lex bot.</p>\n@param botName Name of the Amazon Lex bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "botName",
          "variableType" : "String",
          "documentation" : "<p>Name of the Amazon Lex bot.</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "botAlias",
        "c2jShape" : "BotAlias",
        "deprecated" : false,
        "documentation" : "<p>Alias of the Amazon Lex bot.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Alias of the Amazon Lex bot.</p>\n@param botAlias Alias of the Amazon Lex bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withBotAlias",
        "getterDocumentation" : "/**<p>Alias of the Amazon Lex bot.</p>\n@return Alias of the Amazon Lex bot.*/",
        "getterMethodName" : "getBotAlias",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : "uri",
          "marshallLocation" : "PATH",
          "marshallLocationName" : "botAlias",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "botAlias",
          "uri" : true
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "BotAlias",
        "setterDocumentation" : "/**<p>Alias of the Amazon Lex bot.</p>\n@param botAlias Alias of the Amazon Lex bot.*/",
        "setterMethodName" : "setBotAlias",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "botAlias",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Alias of the Amazon Lex bot.</p>\n@param botAlias Alias of the Amazon Lex bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "botAlias",
          "variableType" : "String",
          "documentation" : "<p>Alias of the Amazon Lex bot.</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "userId",
        "c2jShape" : "UserId",
        "deprecated" : false,
        "documentation" : "<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>\n@param userId User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li>\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withUserId",
        "getterDocumentation" : "/**<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>\n@return User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li>*/",
        "getterMethodName" : "getUserId",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : "uri",
          "marshallLocation" : "PATH",
          "marshallLocationName" : "userId",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "userId",
          "uri" : true
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "UserId",
        "setterDocumentation" : "/**<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>\n@param userId User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li>*/",
        "setterMethodName" : "setUserId",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "userId",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>\n@param userId User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li>\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "userId",
          "variableType" : "String",
          "documentation" : "<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "sessionAttributes",
        "c2jShape" : "StringMap",
        "deprecated" : false,
        "documentation" : "<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>\n@param sessionAttributes A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p>\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withSessionAttributes",
        "getterDocumentation" : "/**<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>\n@return A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p>*/",
        "getterMethodName" : "getSessionAttributes",
        "getterModel" : {
          "returnType" : "java.util.Map<String,String>",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "sessionAttributes",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "sessionAttributes",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : true,
        "mapModel" : {
          "implType" : "java.util.HashMap",
          "interfaceType" : "java.util.Map",
          "keyLocationName" : "key",
          "keyModel" : null,
          "keyType" : "String",
          "valueLocationName" : "value",
          "valueModel" : {
            "c2jName" : "value",
            "c2jShape" : "String",
            "deprecated" : false,
            "documentation" : "",
            "enumType" : null,
            "fluentSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "fluentSetterMethodName" : "withValue",
            "getterDocumentation" : "/**\n@return */",
            "getterMethodName" : "getValue",
            "getterModel" : {
              "returnType" : "String",
              "documentation" : null
            },
            "http" : {
              "additionalMarshallingPath" : null,
              "additionalUnmarshallingPath" : null,
              "flattened" : false,
              "greedy" : false,
              "header" : false,
              "isPayload" : false,
              "isStreaming" : false,
              "location" : null,
              "marshallLocation" : "PAYLOAD",
              "marshallLocationName" : "value",
              "queryString" : false,
              "statusCode" : false,
              "unmarshallLocationName" : "value",
              "uri" : false
            },
            "idempotencyToken" : false,
            "isBinary" : false,
            "list" : false,
            "listModel" : null,
            "map" : false,
            "mapModel" : null,
            "marshallingTargetClass" : "String",
            "marshallingType" : "STRING",
            "name" : "Value",
            "setterDocumentation" : "/**\n@param value */",
            "setterMethodName" : "setValue",
            "setterModel" : {
              "variableDeclarationType" : "String",
              "variableName" : "value",
              "variableType" : "String",
              "documentation" : "",
              "simpleType" : "String",
              "variableSetterType" : "String"
            },
            "simple" : true,
            "varargSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "variable" : {
              "variableDeclarationType" : "String",
              "variableName" : "value",
              "variableType" : "String",
              "documentation" : "",
              "simpleType" : "String",
              "variableSetterType" : "String"
            },
            "xmlNameSpaceUri" : null
          },
          "valueType" : "String",
          "entryType" : "Map.Entry<String, String>",
          "keySimple" : true,
          "templateImplType" : "java.util.HashMap<String,String>",
          "templateType" : "java.util.Map<String,String>",
          "valueList" : false,
          "valueSimple" : true
        },
        "marshallingTargetClass" : "Map",
        "marshallingType" : "MAP",
        "name" : "SessionAttributes",
        "setterDocumentation" : "/**<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>\n@param sessionAttributes A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p>*/",
        "setterMethodName" : "setSessionAttributes",
        "setterModel" : {
          "variableDeclarationType" : "java.util.Map<String,String>",
          "variableName" : "sessionAttributes",
          "variableType" : "java.util.Map<String,String>",
          "documentation" : "",
          "simpleType" : "Map<String,String>",
          "variableSetterType" : "java.util.Map<String,String>"
        },
        "simple" : false,
        "varargSetterDocumentation" : "/**<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>\n@param sessionAttributes A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p>\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "java.util.Map<String,String>",
          "variableName" : "sessionAttributes",
          "variableType" : "java.util.Map<String,String>",
          "documentation" : "<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>",
          "simpleType" : "Map<String,String>",
          "variableSetterType" : "java.util.Map<String,String>"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "inputText",
        "c2jShape" : "Text",
        "deprecated" : false,
        "documentation" : "<p>Text user entered (Amazon Lex interprets this text).</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Text user entered (Amazon Lex interprets this text).</p>\n@param inputText Text user entered (Amazon Lex interprets this text).\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withInputText",
        "getterDocumentation" : "/**<p>Text user entered (Amazon Lex interprets this text).</p>\n@return Text user entered (Amazon Lex interprets this text).*/",
        "getterMethodName" : "getInputText",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "inputText",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "inputText",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "InputText",
        "setterDocumentation" : "/**<p>Text user entered (Amazon Lex interprets this text).</p>\n@param inputText Text user entered (Amazon Lex interprets this text).*/",
        "setterMethodName" : "setInputText",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "inputText",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Text user entered (Amazon Lex interprets this text).</p>\n@param inputText Text user entered (Amazon Lex interprets this text).\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "inputText",
          "variableType" : "String",
          "documentation" : "<p>Text user entered (Amazon Lex interprets this text).</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      } ],
      "membersAsMap" : {
        "BotAlias" : {
          "c2jName" : "botAlias",
          "c2jShape" : "BotAlias",
          "deprecated" : false,
          "documentation" : "<p>Alias of the Amazon Lex bot.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Alias of the Amazon Lex bot.</p>\n@param botAlias Alias of the Amazon Lex bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withBotAlias",
          "getterDocumentation" : "/**<p>Alias of the Amazon Lex bot.</p>\n@return Alias of the Amazon Lex bot.*/",
          "getterMethodName" : "getBotAlias",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : "uri",
            "marshallLocation" : "PATH",
            "marshallLocationName" : "botAlias",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "botAlias",
            "uri" : true
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "BotAlias",
          "setterDocumentation" : "/**<p>Alias of the Amazon Lex bot.</p>\n@param botAlias Alias of the Amazon Lex bot.*/",
          "setterMethodName" : "setBotAlias",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "botAlias",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Alias of the Amazon Lex bot.</p>\n@param botAlias Alias of the Amazon Lex bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "botAlias",
            "variableType" : "String",
            "documentation" : "<p>Alias of the Amazon Lex bot.</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "BotName" : {
          "c2jName" : "botName",
          "c2jShape" : "BotName",
          "deprecated" : false,
          "documentation" : "<p>Name of the Amazon Lex bot.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Name of the Amazon Lex bot.</p>\n@param botName Name of the Amazon Lex bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withBotName",
          "getterDocumentation" : "/**<p>Name of the Amazon Lex bot.</p>\n@return Name of the Amazon Lex bot.*/",
          "getterMethodName" : "getBotName",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : "uri",
            "marshallLocation" : "PATH",
            "marshallLocationName" : "botName",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "botName",
            "uri" : true
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "BotName",
          "setterDocumentation" : "/**<p>Name of the Amazon Lex bot.</p>\n@param botName Name of the Amazon Lex bot.*/",
          "setterMethodName" : "setBotName",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "botName",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Name of the Amazon Lex bot.</p>\n@param botName Name of the Amazon Lex bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "botName",
            "variableType" : "String",
            "documentation" : "<p>Name of the Amazon Lex bot.</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "InputText" : {
          "c2jName" : "inputText",
          "c2jShape" : "Text",
          "deprecated" : false,
          "documentation" : "<p>Text user entered (Amazon Lex interprets this text).</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Text user entered (Amazon Lex interprets this text).</p>\n@param inputText Text user entered (Amazon Lex interprets this text).\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withInputText",
          "getterDocumentation" : "/**<p>Text user entered (Amazon Lex interprets this text).</p>\n@return Text user entered (Amazon Lex interprets this text).*/",
          "getterMethodName" : "getInputText",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "inputText",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "inputText",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "InputText",
          "setterDocumentation" : "/**<p>Text user entered (Amazon Lex interprets this text).</p>\n@param inputText Text user entered (Amazon Lex interprets this text).*/",
          "setterMethodName" : "setInputText",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "inputText",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Text user entered (Amazon Lex interprets this text).</p>\n@param inputText Text user entered (Amazon Lex interprets this text).\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "inputText",
            "variableType" : "String",
            "documentation" : "<p>Text user entered (Amazon Lex interprets this text).</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "SessionAttributes" : {
          "c2jName" : "sessionAttributes",
          "c2jShape" : "StringMap",
          "deprecated" : false,
          "documentation" : "<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>\n@param sessionAttributes A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p>\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withSessionAttributes",
          "getterDocumentation" : "/**<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>\n@return A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p>*/",
          "getterMethodName" : "getSessionAttributes",
          "getterModel" : {
            "returnType" : "java.util.Map<String,String>",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "sessionAttributes",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "sessionAttributes",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : true,
          "mapModel" : {
            "implType" : "java.util.HashMap",
            "interfaceType" : "java.util.Map",
            "keyLocationName" : "key",
            "keyModel" : null,
            "keyType" : "String",
            "valueLocationName" : "value",
            "valueModel" : {
              "c2jName" : "value",
              "c2jShape" : "String",
              "deprecated" : false,
              "documentation" : "",
              "enumType" : null,
              "fluentSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "fluentSetterMethodName" : "withValue",
              "getterDocumentation" : "/**\n@return */",
              "getterMethodName" : "getValue",
              "getterModel" : {
                "returnType" : "String",
                "documentation" : null
              },
              "http" : {
                "additionalMarshallingPath" : null,
                "additionalUnmarshallingPath" : null,
                "flattened" : false,
                "greedy" : false,
                "header" : false,
                "isPayload" : false,
                "isStreaming" : false,
                "location" : null,
                "marshallLocation" : "PAYLOAD",
                "marshallLocationName" : "value",
                "queryString" : false,
                "statusCode" : false,
                "unmarshallLocationName" : "value",
                "uri" : false
              },
              "idempotencyToken" : false,
              "isBinary" : false,
              "list" : false,
              "listModel" : null,
              "map" : false,
              "mapModel" : null,
              "marshallingTargetClass" : "String",
              "marshallingType" : "STRING",
              "name" : "Value",
              "setterDocumentation" : "/**\n@param value */",
              "setterMethodName" : "setValue",
              "setterModel" : {
                "variableDeclarationType" : "String",
                "variableName" : "value",
                "variableType" : "String",
                "documentation" : "",
                "simpleType" : "String",
                "variableSetterType" : "String"
              },
              "simple" : true,
              "varargSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "variable" : {
                "variableDeclarationType" : "String",
                "variableName" : "value",
                "variableType" : "String",
                "documentation" : "",
                "simpleType" : "String",
                "variableSetterType" : "String"
              },
              "xmlNameSpaceUri" : null
            },
            "valueType" : "String",
            "entryType" : "Map.Entry<String, String>",
            "keySimple" : true,
            "templateImplType" : "java.util.HashMap<String,String>",
            "templateType" : "java.util.Map<String,String>",
            "valueList" : false,
            "valueSimple" : true
          },
          "marshallingTargetClass" : "Map",
          "marshallingType" : "MAP",
          "name" : "SessionAttributes",
          "setterDocumentation" : "/**<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>\n@param sessionAttributes A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p>*/",
          "setterMethodName" : "setSessionAttributes",
          "setterModel" : {
            "variableDeclarationType" : "java.util.Map<String,String>",
            "variableName" : "sessionAttributes",
            "variableType" : "java.util.Map<String,String>",
            "documentation" : "",
            "simpleType" : "Map<String,String>",
            "variableSetterType" : "java.util.Map<String,String>"
          },
          "simple" : false,
          "varargSetterDocumentation" : "/**<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>\n@param sessionAttributes A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p>\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "java.util.Map<String,String>",
            "variableName" : "sessionAttributes",
            "variableType" : "java.util.Map<String,String>",
            "documentation" : "<p> A session represents the dialog between a user and Amazon Lex. At runtime, a client application can pass contextual information (session attributes) in the request. For example, <code>\"FirstName\" : \"Joe\"</code>. Amazon Lex passes these session attributes to the AWS Lambda functions configured for the intent (see <code>dialogCodeHook</code> and <code>fulfillmentActivity.codeHook</code> in <code>CreateIntent</code>). </p> <p>In your Lambda function, you can use the session attributes for customization. Some examples are:</p> <ul> <li> <p> In a pizza ordering application, if you can pass user location as a session attribute (for example, <code>\"Location\" : \"111 Maple street\"</code>), your Lambda function might use this information to determine the closest pizzeria to place the order. </p> </li> <li> <p> Use session attributes to personalize prompts. For example, you pass in user name as a session attribute (<code>\"FirstName\" : \"Joe\"</code>), you might configure subsequent prompts to refer to this attribute, as <code>$session.FirstName\"</code>. At runtime, Amazon Lex substitutes a real value when it generates a prompt, such as \"Hello Joe, what would you like to order?\" </p> </li> </ul> <note> <p> Amazon Lex does not persist session attributes. </p> <p> If the intent is configured without a Lambda function to process the intent (that is, the client application to process the intent), Amazon Lex simply returns the session attributes back to the client application. </p> <p> If the intent is configured with a Lambda function to process the intent, Amazon Lex passes the incoming session attributes to the Lambda function. The Lambda function must return these session attributes if you want Amazon Lex to return them back to the client. </p> </note>",
            "simpleType" : "Map<String,String>",
            "variableSetterType" : "java.util.Map<String,String>"
          },
          "xmlNameSpaceUri" : null
        },
        "UserId" : {
          "c2jName" : "userId",
          "c2jShape" : "UserId",
          "deprecated" : false,
          "documentation" : "<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>\n@param userId User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li>\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withUserId",
          "getterDocumentation" : "/**<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>\n@return User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li>*/",
          "getterMethodName" : "getUserId",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : "uri",
            "marshallLocation" : "PATH",
            "marshallLocationName" : "userId",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "userId",
            "uri" : true
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "UserId",
          "setterDocumentation" : "/**<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>\n@param userId User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li>*/",
          "setterMethodName" : "setUserId",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "userId",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>\n@param userId User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li>\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "userId",
            "variableType" : "String",
            "documentation" : "<p>User ID of your client application. Typically, each of your application users should have a unique ID. Note the following considerations: </p> <ul> <li> <p> If you want a user to start a conversation on one mobile device and continue the conversation on another device, you might choose a user-specific identifier, such as a login or Amazon Cognito user ID (assuming your application is using Amazon Cognito). </p> </li> <li> <p> If you want the same user to be able to have two independent conversations on two different devices, you might choose a device-specific identifier, such as device ID, or some globally unique identifier. </p> </li> </ul>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        }
      },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : [ "botName", "botAlias", "userId", "inputText" ],
      "shapeName" : "PostTextRequest",
      "unmarshaller" : null,
      "variable" : {
        "variableDeclarationType" : "PostTextRequest",
        "variableName" : "postTextRequest",
        "variableType" : "PostTextRequest",
        "documentation" : null,
        "simpleType" : "PostTextRequest",
        "variableSetterType" : "PostTextRequest"
      },
      "wrapper" : false
    },
    "PostTextResult" : {
      "c2jName" : "PostTextResponse",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "",
      "enums" : null,
      "errorCode" : null,
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ {
        "c2jName" : "intentName",
        "c2jShape" : "IntentName",
        "deprecated" : false,
        "documentation" : "<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>\n@param intentName Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withIntentName",
        "getterDocumentation" : "/**<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>\n@return Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot.*/",
        "getterMethodName" : "getIntentName",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "intentName",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "intentName",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "IntentName",
        "setterDocumentation" : "/**<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>\n@param intentName Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot.*/",
        "setterMethodName" : "setIntentName",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "intentName",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>\n@param intentName Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "intentName",
          "variableType" : "String",
          "documentation" : "<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "slots",
        "c2jShape" : "StringMap",
        "deprecated" : false,
        "documentation" : "<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>\n@param slots Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withSlots",
        "getterDocumentation" : "/**<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>\n@return Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation.*/",
        "getterMethodName" : "getSlots",
        "getterModel" : {
          "returnType" : "java.util.Map<String,String>",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "slots",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "slots",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : true,
        "mapModel" : {
          "implType" : "java.util.HashMap",
          "interfaceType" : "java.util.Map",
          "keyLocationName" : "key",
          "keyModel" : null,
          "keyType" : "String",
          "valueLocationName" : "value",
          "valueModel" : {
            "c2jName" : "value",
            "c2jShape" : "String",
            "deprecated" : false,
            "documentation" : "",
            "enumType" : null,
            "fluentSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "fluentSetterMethodName" : "withValue",
            "getterDocumentation" : "/**\n@return */",
            "getterMethodName" : "getValue",
            "getterModel" : {
              "returnType" : "String",
              "documentation" : null
            },
            "http" : {
              "additionalMarshallingPath" : null,
              "additionalUnmarshallingPath" : null,
              "flattened" : false,
              "greedy" : false,
              "header" : false,
              "isPayload" : false,
              "isStreaming" : false,
              "location" : null,
              "marshallLocation" : "PAYLOAD",
              "marshallLocationName" : "value",
              "queryString" : false,
              "statusCode" : false,
              "unmarshallLocationName" : "value",
              "uri" : false
            },
            "idempotencyToken" : false,
            "isBinary" : false,
            "list" : false,
            "listModel" : null,
            "map" : false,
            "mapModel" : null,
            "marshallingTargetClass" : "String",
            "marshallingType" : "STRING",
            "name" : "Value",
            "setterDocumentation" : "/**\n@param value */",
            "setterMethodName" : "setValue",
            "setterModel" : {
              "variableDeclarationType" : "String",
              "variableName" : "value",
              "variableType" : "String",
              "documentation" : "",
              "simpleType" : "String",
              "variableSetterType" : "String"
            },
            "simple" : true,
            "varargSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "variable" : {
              "variableDeclarationType" : "String",
              "variableName" : "value",
              "variableType" : "String",
              "documentation" : "",
              "simpleType" : "String",
              "variableSetterType" : "String"
            },
            "xmlNameSpaceUri" : null
          },
          "valueType" : "String",
          "entryType" : "Map.Entry<String, String>",
          "keySimple" : true,
          "templateImplType" : "java.util.HashMap<String,String>",
          "templateType" : "java.util.Map<String,String>",
          "valueList" : false,
          "valueSimple" : true
        },
        "marshallingTargetClass" : "Map",
        "marshallingType" : "MAP",
        "name" : "Slots",
        "setterDocumentation" : "/**<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>\n@param slots Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation.*/",
        "setterMethodName" : "setSlots",
        "setterModel" : {
          "variableDeclarationType" : "java.util.Map<String,String>",
          "variableName" : "slots",
          "variableType" : "java.util.Map<String,String>",
          "documentation" : "",
          "simpleType" : "Map<String,String>",
          "variableSetterType" : "java.util.Map<String,String>"
        },
        "simple" : false,
        "varargSetterDocumentation" : "/**<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>\n@param slots Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "java.util.Map<String,String>",
          "variableName" : "slots",
          "variableType" : "java.util.Map<String,String>",
          "documentation" : "<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>",
          "simpleType" : "Map<String,String>",
          "variableSetterType" : "java.util.Map<String,String>"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "sessionAttributes",
        "c2jShape" : "StringMap",
        "deprecated" : false,
        "documentation" : "<p>Map of key value pairs representing the session specific context information.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Map of key value pairs representing the session specific context information.</p>\n@param sessionAttributes Map of key value pairs representing the session specific context information.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withSessionAttributes",
        "getterDocumentation" : "/**<p>Map of key value pairs representing the session specific context information.</p>\n@return Map of key value pairs representing the session specific context information.*/",
        "getterMethodName" : "getSessionAttributes",
        "getterModel" : {
          "returnType" : "java.util.Map<String,String>",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "sessionAttributes",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "sessionAttributes",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : true,
        "mapModel" : {
          "implType" : "java.util.HashMap",
          "interfaceType" : "java.util.Map",
          "keyLocationName" : "key",
          "keyModel" : null,
          "keyType" : "String",
          "valueLocationName" : "value",
          "valueModel" : {
            "c2jName" : "value",
            "c2jShape" : "String",
            "deprecated" : false,
            "documentation" : "",
            "enumType" : null,
            "fluentSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "fluentSetterMethodName" : "withValue",
            "getterDocumentation" : "/**\n@return */",
            "getterMethodName" : "getValue",
            "getterModel" : {
              "returnType" : "String",
              "documentation" : null
            },
            "http" : {
              "additionalMarshallingPath" : null,
              "additionalUnmarshallingPath" : null,
              "flattened" : false,
              "greedy" : false,
              "header" : false,
              "isPayload" : false,
              "isStreaming" : false,
              "location" : null,
              "marshallLocation" : "PAYLOAD",
              "marshallLocationName" : "value",
              "queryString" : false,
              "statusCode" : false,
              "unmarshallLocationName" : "value",
              "uri" : false
            },
            "idempotencyToken" : false,
            "isBinary" : false,
            "list" : false,
            "listModel" : null,
            "map" : false,
            "mapModel" : null,
            "marshallingTargetClass" : "String",
            "marshallingType" : "STRING",
            "name" : "Value",
            "setterDocumentation" : "/**\n@param value */",
            "setterMethodName" : "setValue",
            "setterModel" : {
              "variableDeclarationType" : "String",
              "variableName" : "value",
              "variableType" : "String",
              "documentation" : "",
              "simpleType" : "String",
              "variableSetterType" : "String"
            },
            "simple" : true,
            "varargSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "variable" : {
              "variableDeclarationType" : "String",
              "variableName" : "value",
              "variableType" : "String",
              "documentation" : "",
              "simpleType" : "String",
              "variableSetterType" : "String"
            },
            "xmlNameSpaceUri" : null
          },
          "valueType" : "String",
          "entryType" : "Map.Entry<String, String>",
          "keySimple" : true,
          "templateImplType" : "java.util.HashMap<String,String>",
          "templateType" : "java.util.Map<String,String>",
          "valueList" : false,
          "valueSimple" : true
        },
        "marshallingTargetClass" : "Map",
        "marshallingType" : "MAP",
        "name" : "SessionAttributes",
        "setterDocumentation" : "/**<p>Map of key value pairs representing the session specific context information.</p>\n@param sessionAttributes Map of key value pairs representing the session specific context information.*/",
        "setterMethodName" : "setSessionAttributes",
        "setterModel" : {
          "variableDeclarationType" : "java.util.Map<String,String>",
          "variableName" : "sessionAttributes",
          "variableType" : "java.util.Map<String,String>",
          "documentation" : "",
          "simpleType" : "Map<String,String>",
          "variableSetterType" : "java.util.Map<String,String>"
        },
        "simple" : false,
        "varargSetterDocumentation" : "/**<p>Map of key value pairs representing the session specific context information.</p>\n@param sessionAttributes Map of key value pairs representing the session specific context information.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "java.util.Map<String,String>",
          "variableName" : "sessionAttributes",
          "variableType" : "java.util.Map<String,String>",
          "documentation" : "<p>Map of key value pairs representing the session specific context information.</p>",
          "simpleType" : "Map<String,String>",
          "variableSetterType" : "java.util.Map<String,String>"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "message",
        "c2jShape" : "Text",
        "deprecated" : false,
        "documentation" : "<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>\n@param message Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withMessage",
        "getterDocumentation" : "/**<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>\n@return Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response.*/",
        "getterMethodName" : "getMessage",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "message",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "message",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "Message",
        "setterDocumentation" : "/**<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>\n@param message Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response.*/",
        "setterMethodName" : "setMessage",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "message",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>\n@param message Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "message",
          "variableType" : "String",
          "documentation" : "<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "dialogState",
        "c2jShape" : "DialogState",
        "deprecated" : false,
        "documentation" : "<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>",
        "enumType" : "DialogState",
        "fluentSetterDocumentation" : "/**<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>\n@param dialogState Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li>\n@return Returns a reference to this object so that method calls can be chained together.\n@see DialogState*/",
        "fluentSetterMethodName" : "withDialogState",
        "getterDocumentation" : "/**<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>\n@return Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li>\n@see DialogState*/",
        "getterMethodName" : "getDialogState",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "dialogState",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "dialogState",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "DialogState",
        "setterDocumentation" : "/**<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>\n@param dialogState Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li>\n@see DialogState*/",
        "setterMethodName" : "setDialogState",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "dialogState",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>\n@param dialogState Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li>\n@return Returns a reference to this object so that method calls can be chained together.\n@see DialogState*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "dialogState",
          "variableType" : "String",
          "documentation" : "<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "slotToElicit",
        "c2jShape" : "String",
        "deprecated" : false,
        "documentation" : "<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>\n@param slotToElicit If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withSlotToElicit",
        "getterDocumentation" : "/**<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>\n@return If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value.*/",
        "getterMethodName" : "getSlotToElicit",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "slotToElicit",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "slotToElicit",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "SlotToElicit",
        "setterDocumentation" : "/**<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>\n@param slotToElicit If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value.*/",
        "setterMethodName" : "setSlotToElicit",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "slotToElicit",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>\n@param slotToElicit If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "slotToElicit",
          "variableType" : "String",
          "documentation" : "<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "responseCard",
        "c2jShape" : "ResponseCard",
        "deprecated" : false,
        "documentation" : "<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>\n@param responseCard Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withResponseCard",
        "getterDocumentation" : "/**<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>\n@return Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected.*/",
        "getterMethodName" : "getResponseCard",
        "getterModel" : {
          "returnType" : "ResponseCard",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "responseCard",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "responseCard",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "StructuredPojo",
        "marshallingType" : "STRUCTURED",
        "name" : "ResponseCard",
        "setterDocumentation" : "/**<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>\n@param responseCard Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected.*/",
        "setterMethodName" : "setResponseCard",
        "setterModel" : {
          "variableDeclarationType" : "ResponseCard",
          "variableName" : "responseCard",
          "variableType" : "ResponseCard",
          "documentation" : "",
          "simpleType" : "ResponseCard",
          "variableSetterType" : "ResponseCard"
        },
        "simple" : false,
        "varargSetterDocumentation" : "/**<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>\n@param responseCard Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "ResponseCard",
          "variableName" : "responseCard",
          "variableType" : "ResponseCard",
          "documentation" : "<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>",
          "simpleType" : "ResponseCard",
          "variableSetterType" : "ResponseCard"
        },
        "xmlNameSpaceUri" : null
      } ],
      "membersAsMap" : {
        "DialogState" : {
          "c2jName" : "dialogState",
          "c2jShape" : "DialogState",
          "deprecated" : false,
          "documentation" : "<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>",
          "enumType" : "DialogState",
          "fluentSetterDocumentation" : "/**<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>\n@param dialogState Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li>\n@return Returns a reference to this object so that method calls can be chained together.\n@see DialogState*/",
          "fluentSetterMethodName" : "withDialogState",
          "getterDocumentation" : "/**<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>\n@return Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li>\n@see DialogState*/",
          "getterMethodName" : "getDialogState",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "dialogState",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "dialogState",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "DialogState",
          "setterDocumentation" : "/**<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>\n@param dialogState Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li>\n@see DialogState*/",
          "setterMethodName" : "setDialogState",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "dialogState",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>\n@param dialogState Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li>\n@return Returns a reference to this object so that method calls can be chained together.\n@see DialogState*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "dialogState",
            "variableType" : "String",
            "documentation" : "<p>Represents the message type to be conveyed to the user. For example: </p> <ul> <li> <p> <code>ElicitIntent</code> – Amazon Lex wants to elicit user intent. For example, Amazon Lex did not understand the first utterances such as \"I want to order pizza\", which indicates the OrderPizza intent. If Amazon Lex doesn't understand the intent, it returns this <code>dialogState</code>. Another example is when your intent is configured with a follow up prompt. For example, after OrderPizza intent is fulfilled, the intent might have a follow up prompt such as \" Do you want to order a drink or desert?\" In this case, Amazon Lex returns this <code>dialogState</code>. </p> </li> <li> <p> <code>ConfirmIntent</code> – Amazon Lex is expecting a yes/no response from the user indicating whether to go ahead and fulfill the intent (for example, OK to go ahead and order the pizza). In addition to a yes/no reply, the user might provide a response with additional slot information (either new slot information or changes to the existing slot values). For example, \"Yes, but change to thick crust.\" Amazon Lex understands the additional information and updates the intent slots accordingly. </p> <p> Consider another example. Before fulfilling an order, your application might prompt for confirmation such as \"Do you want to place this pizza order?\" A user might reply with \"No, I want to order a drink.\" Amazon Lex recognizes the new OrderDrink intent. </p> </li> <li> <p> <code>ElicitSlot</code> – Amazon Lex is expecting a value of a slot for the current intent. For example, suppose Amazon Lex asks, \"What size pizza would you like?\" A user might reply with \"Medium pepperoni pizza.\" Amazon Lex recognizes the size and the topping as the two separate slot values. </p> </li> <li> <p> <code>Fulfilled</code> – Conveys that the Lambda function has successfully fulfilled the intent. If Lambda function returns a statement/message to convey the fulfillment result, Amazon Lex passes this string to the client. If not, Amazon Lex looks for <code>conclusionStatement</code> that you configured for the intent. </p> <p> If both the Lambda function statement and the <code>conclusionStatement</code> are missing, Amazon Lex throws a bad request exception. </p> </li> <li> <p> <code>ReadyForFulfillment</code> – conveys that the client has to do the fulfillment work for the intent. This is the case when the current intent is configured with <code>ReturnIntent</code> as the <code>fulfillmentActivity </code>, where Amazon Lex returns this state to client. </p> </li> <li> <p> <code>Failed</code> – Conversation with the user failed. Some of the reasons for this <code>dialogState</code> are: after the configured number of attempts the user didn't provide an appropriate response, or the Lambda function failed to fulfill an intent. </p> </li> </ul>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "IntentName" : {
          "c2jName" : "intentName",
          "c2jShape" : "IntentName",
          "deprecated" : false,
          "documentation" : "<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>\n@param intentName Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withIntentName",
          "getterDocumentation" : "/**<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>\n@return Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot.*/",
          "getterMethodName" : "getIntentName",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "intentName",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "intentName",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "IntentName",
          "setterDocumentation" : "/**<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>\n@param intentName Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot.*/",
          "setterMethodName" : "setIntentName",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "intentName",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>\n@param intentName Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "intentName",
            "variableType" : "String",
            "documentation" : "<p>Intent Amazon Lex inferred from the user input text. This is one of the intents configured for the bot. </p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "Message" : {
          "c2jName" : "message",
          "c2jShape" : "Text",
          "deprecated" : false,
          "documentation" : "<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>\n@param message Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withMessage",
          "getterDocumentation" : "/**<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>\n@return Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response.*/",
          "getterMethodName" : "getMessage",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "message",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "message",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "Message",
          "setterDocumentation" : "/**<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>\n@param message Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response.*/",
          "setterMethodName" : "setMessage",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "message",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>\n@param message Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "message",
            "variableType" : "String",
            "documentation" : "<p> Prompt (or statement) to convey to the user. This is based on the application configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the <code>clarificationPrompt</code> configured for the application. In another example, if the intent requires confirmation before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Suppose the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. In that situation, Amazon Lex sends that message in the response. </p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "ResponseCard" : {
          "c2jName" : "responseCard",
          "c2jShape" : "ResponseCard",
          "deprecated" : false,
          "documentation" : "<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>\n@param responseCard Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withResponseCard",
          "getterDocumentation" : "/**<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>\n@return Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected.*/",
          "getterMethodName" : "getResponseCard",
          "getterModel" : {
            "returnType" : "ResponseCard",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "responseCard",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "responseCard",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "StructuredPojo",
          "marshallingType" : "STRUCTURED",
          "name" : "ResponseCard",
          "setterDocumentation" : "/**<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>\n@param responseCard Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected.*/",
          "setterMethodName" : "setResponseCard",
          "setterModel" : {
            "variableDeclarationType" : "ResponseCard",
            "variableName" : "responseCard",
            "variableType" : "ResponseCard",
            "documentation" : "",
            "simpleType" : "ResponseCard",
            "variableSetterType" : "ResponseCard"
          },
          "simple" : false,
          "varargSetterDocumentation" : "/**<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>\n@param responseCard Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "ResponseCard",
            "variableName" : "responseCard",
            "variableType" : "ResponseCard",
            "documentation" : "<p>Represents the options that the user has to respond to the current prompt. Amazon Lex sends this in the response only if the <code>dialogState</code> value indicates that a user response is expected. </p>",
            "simpleType" : "ResponseCard",
            "variableSetterType" : "ResponseCard"
          },
          "xmlNameSpaceUri" : null
        },
        "SessionAttributes" : {
          "c2jName" : "sessionAttributes",
          "c2jShape" : "StringMap",
          "deprecated" : false,
          "documentation" : "<p>Map of key value pairs representing the session specific context information.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Map of key value pairs representing the session specific context information.</p>\n@param sessionAttributes Map of key value pairs representing the session specific context information.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withSessionAttributes",
          "getterDocumentation" : "/**<p>Map of key value pairs representing the session specific context information.</p>\n@return Map of key value pairs representing the session specific context information.*/",
          "getterMethodName" : "getSessionAttributes",
          "getterModel" : {
            "returnType" : "java.util.Map<String,String>",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "sessionAttributes",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "sessionAttributes",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : true,
          "mapModel" : {
            "implType" : "java.util.HashMap",
            "interfaceType" : "java.util.Map",
            "keyLocationName" : "key",
            "keyModel" : null,
            "keyType" : "String",
            "valueLocationName" : "value",
            "valueModel" : {
              "c2jName" : "value",
              "c2jShape" : "String",
              "deprecated" : false,
              "documentation" : "",
              "enumType" : null,
              "fluentSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "fluentSetterMethodName" : "withValue",
              "getterDocumentation" : "/**\n@return */",
              "getterMethodName" : "getValue",
              "getterModel" : {
                "returnType" : "String",
                "documentation" : null
              },
              "http" : {
                "additionalMarshallingPath" : null,
                "additionalUnmarshallingPath" : null,
                "flattened" : false,
                "greedy" : false,
                "header" : false,
                "isPayload" : false,
                "isStreaming" : false,
                "location" : null,
                "marshallLocation" : "PAYLOAD",
                "marshallLocationName" : "value",
                "queryString" : false,
                "statusCode" : false,
                "unmarshallLocationName" : "value",
                "uri" : false
              },
              "idempotencyToken" : false,
              "isBinary" : false,
              "list" : false,
              "listModel" : null,
              "map" : false,
              "mapModel" : null,
              "marshallingTargetClass" : "String",
              "marshallingType" : "STRING",
              "name" : "Value",
              "setterDocumentation" : "/**\n@param value */",
              "setterMethodName" : "setValue",
              "setterModel" : {
                "variableDeclarationType" : "String",
                "variableName" : "value",
                "variableType" : "String",
                "documentation" : "",
                "simpleType" : "String",
                "variableSetterType" : "String"
              },
              "simple" : true,
              "varargSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "variable" : {
                "variableDeclarationType" : "String",
                "variableName" : "value",
                "variableType" : "String",
                "documentation" : "",
                "simpleType" : "String",
                "variableSetterType" : "String"
              },
              "xmlNameSpaceUri" : null
            },
            "valueType" : "String",
            "entryType" : "Map.Entry<String, String>",
            "keySimple" : true,
            "templateImplType" : "java.util.HashMap<String,String>",
            "templateType" : "java.util.Map<String,String>",
            "valueList" : false,
            "valueSimple" : true
          },
          "marshallingTargetClass" : "Map",
          "marshallingType" : "MAP",
          "name" : "SessionAttributes",
          "setterDocumentation" : "/**<p>Map of key value pairs representing the session specific context information.</p>\n@param sessionAttributes Map of key value pairs representing the session specific context information.*/",
          "setterMethodName" : "setSessionAttributes",
          "setterModel" : {
            "variableDeclarationType" : "java.util.Map<String,String>",
            "variableName" : "sessionAttributes",
            "variableType" : "java.util.Map<String,String>",
            "documentation" : "",
            "simpleType" : "Map<String,String>",
            "variableSetterType" : "java.util.Map<String,String>"
          },
          "simple" : false,
          "varargSetterDocumentation" : "/**<p>Map of key value pairs representing the session specific context information.</p>\n@param sessionAttributes Map of key value pairs representing the session specific context information.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "java.util.Map<String,String>",
            "variableName" : "sessionAttributes",
            "variableType" : "java.util.Map<String,String>",
            "documentation" : "<p>Map of key value pairs representing the session specific context information.</p>",
            "simpleType" : "Map<String,String>",
            "variableSetterType" : "java.util.Map<String,String>"
          },
          "xmlNameSpaceUri" : null
        },
        "SlotToElicit" : {
          "c2jName" : "slotToElicit",
          "c2jShape" : "String",
          "deprecated" : false,
          "documentation" : "<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>\n@param slotToElicit If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withSlotToElicit",
          "getterDocumentation" : "/**<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>\n@return If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value.*/",
          "getterMethodName" : "getSlotToElicit",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "slotToElicit",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "slotToElicit",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "SlotToElicit",
          "setterDocumentation" : "/**<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>\n@param slotToElicit If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value.*/",
          "setterMethodName" : "setSlotToElicit",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "slotToElicit",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>\n@param slotToElicit If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "slotToElicit",
            "variableType" : "String",
            "documentation" : "<p>If <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the slot for which Amazon Lex is eliciting a value. </p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "Slots" : {
          "c2jName" : "slots",
          "c2jShape" : "StringMap",
          "deprecated" : false,
          "documentation" : "<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>\n@param slots Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withSlots",
          "getterDocumentation" : "/**<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>\n@return Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation.*/",
          "getterMethodName" : "getSlots",
          "getterModel" : {
            "returnType" : "java.util.Map<String,String>",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "slots",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "slots",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : true,
          "mapModel" : {
            "implType" : "java.util.HashMap",
            "interfaceType" : "java.util.Map",
            "keyLocationName" : "key",
            "keyModel" : null,
            "keyType" : "String",
            "valueLocationName" : "value",
            "valueModel" : {
              "c2jName" : "value",
              "c2jShape" : "String",
              "deprecated" : false,
              "documentation" : "",
              "enumType" : null,
              "fluentSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "fluentSetterMethodName" : "withValue",
              "getterDocumentation" : "/**\n@return */",
              "getterMethodName" : "getValue",
              "getterModel" : {
                "returnType" : "String",
                "documentation" : null
              },
              "http" : {
                "additionalMarshallingPath" : null,
                "additionalUnmarshallingPath" : null,
                "flattened" : false,
                "greedy" : false,
                "header" : false,
                "isPayload" : false,
                "isStreaming" : false,
                "location" : null,
                "marshallLocation" : "PAYLOAD",
                "marshallLocationName" : "value",
                "queryString" : false,
                "statusCode" : false,
                "unmarshallLocationName" : "value",
                "uri" : false
              },
              "idempotencyToken" : false,
              "isBinary" : false,
              "list" : false,
              "listModel" : null,
              "map" : false,
              "mapModel" : null,
              "marshallingTargetClass" : "String",
              "marshallingType" : "STRING",
              "name" : "Value",
              "setterDocumentation" : "/**\n@param value */",
              "setterMethodName" : "setValue",
              "setterModel" : {
                "variableDeclarationType" : "String",
                "variableName" : "value",
                "variableType" : "String",
                "documentation" : "",
                "simpleType" : "String",
                "variableSetterType" : "String"
              },
              "simple" : true,
              "varargSetterDocumentation" : "/**\n@param value \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "variable" : {
                "variableDeclarationType" : "String",
                "variableName" : "value",
                "variableType" : "String",
                "documentation" : "",
                "simpleType" : "String",
                "variableSetterType" : "String"
              },
              "xmlNameSpaceUri" : null
            },
            "valueType" : "String",
            "entryType" : "Map.Entry<String, String>",
            "keySimple" : true,
            "templateImplType" : "java.util.HashMap<String,String>",
            "templateType" : "java.util.Map<String,String>",
            "valueList" : false,
            "valueSimple" : true
          },
          "marshallingTargetClass" : "Map",
          "marshallingType" : "MAP",
          "name" : "Slots",
          "setterDocumentation" : "/**<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>\n@param slots Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation.*/",
          "setterMethodName" : "setSlots",
          "setterModel" : {
            "variableDeclarationType" : "java.util.Map<String,String>",
            "variableName" : "slots",
            "variableType" : "java.util.Map<String,String>",
            "documentation" : "",
            "simpleType" : "Map<String,String>",
            "variableSetterType" : "java.util.Map<String,String>"
          },
          "simple" : false,
          "varargSetterDocumentation" : "/**<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>\n@param slots Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "java.util.Map<String,String>",
            "variableName" : "slots",
            "variableType" : "java.util.Map<String,String>",
            "documentation" : "<p> Intent slots (name/value pairs) Amazon Lex detected so far from the user input in the conversation. </p>",
            "simpleType" : "Map<String,String>",
            "variableSetterType" : "java.util.Map<String,String>"
          },
          "xmlNameSpaceUri" : null
        }
      },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "PostTextResult",
      "unmarshaller" : {
        "flattened" : false,
        "resultWrapper" : null
      },
      "variable" : {
        "variableDeclarationType" : "PostTextResult",
        "variableName" : "postTextResult",
        "variableType" : "PostTextResult",
        "documentation" : null,
        "simpleType" : "PostTextResult",
        "variableSetterType" : "PostTextResult"
      },
      "wrapper" : false
    },
    "ResponseCard" : {
      "c2jName" : "ResponseCard",
      "customization" : {
        "artificialResultWrapper" : null,
        "skipGeneratingMarshaller" : false,
        "skipGeneratingModelClass" : false,
        "skipGeneratingUnmarshaller" : false
      },
      "deprecated" : false,
      "documentation" : "<p>If you configure a response card when creating your bots, Amazon Lex substitutes the session attributes and slot values available, and then returns it. The response card can also come from a Lambda function ( <code>dialogCodeHook</code> and <code>fulfillmentActivity</code> on an intent).</p>",
      "enums" : null,
      "errorCode" : null,
      "hasHeaderMember" : false,
      "hasPayloadMember" : false,
      "hasStatusCodeMember" : false,
      "hasStreamingMember" : false,
      "marshaller" : null,
      "members" : [ {
        "c2jName" : "version",
        "c2jShape" : "String",
        "deprecated" : false,
        "documentation" : "<p>Version of response card format.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>Version of response card format.</p>\n@param version Version of response card format.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withVersion",
        "getterDocumentation" : "/**<p>Version of response card format.</p>\n@return Version of response card format.*/",
        "getterMethodName" : "getVersion",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "version",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "version",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "Version",
        "setterDocumentation" : "/**<p>Version of response card format.</p>\n@param version Version of response card format.*/",
        "setterMethodName" : "setVersion",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "version",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Version of response card format.</p>\n@param version Version of response card format.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "version",
          "variableType" : "String",
          "documentation" : "<p>Version of response card format.</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "contentType",
        "c2jShape" : "ContentType",
        "deprecated" : false,
        "documentation" : "<p>Content type of the response.</p>",
        "enumType" : "ContentType",
        "fluentSetterDocumentation" : "/**<p>Content type of the response.</p>\n@param contentType Content type of the response.\n@return Returns a reference to this object so that method calls can be chained together.\n@see ContentType*/",
        "fluentSetterMethodName" : "withContentType",
        "getterDocumentation" : "/**<p>Content type of the response.</p>\n@return Content type of the response.\n@see ContentType*/",
        "getterMethodName" : "getContentType",
        "getterModel" : {
          "returnType" : "String",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "contentType",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "contentType",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : false,
        "listModel" : null,
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "String",
        "marshallingType" : "STRING",
        "name" : "ContentType",
        "setterDocumentation" : "/**<p>Content type of the response.</p>\n@param contentType Content type of the response.\n@see ContentType*/",
        "setterMethodName" : "setContentType",
        "setterModel" : {
          "variableDeclarationType" : "String",
          "variableName" : "contentType",
          "variableType" : "String",
          "documentation" : "",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "simple" : true,
        "varargSetterDocumentation" : "/**<p>Content type of the response.</p>\n@param contentType Content type of the response.\n@return Returns a reference to this object so that method calls can be chained together.\n@see ContentType*/",
        "variable" : {
          "variableDeclarationType" : "String",
          "variableName" : "contentType",
          "variableType" : "String",
          "documentation" : "<p>Content type of the response.</p>",
          "simpleType" : "String",
          "variableSetterType" : "String"
        },
        "xmlNameSpaceUri" : null
      }, {
        "c2jName" : "genericAttachments",
        "c2jShape" : "genericAttachmentList",
        "deprecated" : false,
        "documentation" : "<p>An array of attachment objects representing options.</p>",
        "enumType" : null,
        "fluentSetterDocumentation" : "/**<p>An array of attachment objects representing options.</p>\n@param genericAttachments An array of attachment objects representing options.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "fluentSetterMethodName" : "withGenericAttachments",
        "getterDocumentation" : "/**<p>An array of attachment objects representing options.</p>\n@return An array of attachment objects representing options.*/",
        "getterMethodName" : "getGenericAttachments",
        "getterModel" : {
          "returnType" : "java.util.List<GenericAttachment>",
          "documentation" : null
        },
        "http" : {
          "additionalMarshallingPath" : null,
          "additionalUnmarshallingPath" : null,
          "flattened" : false,
          "greedy" : false,
          "header" : false,
          "isPayload" : false,
          "isStreaming" : false,
          "location" : null,
          "marshallLocation" : "PAYLOAD",
          "marshallLocationName" : "genericAttachments",
          "queryString" : false,
          "statusCode" : false,
          "unmarshallLocationName" : "genericAttachments",
          "uri" : false
        },
        "idempotencyToken" : false,
        "isBinary" : false,
        "list" : true,
        "listModel" : {
          "implType" : "java.util.ArrayList",
          "interfaceType" : "java.util.List",
          "listMemberModel" : {
            "c2jName" : "member",
            "c2jShape" : "GenericAttachment",
            "deprecated" : false,
            "documentation" : "",
            "enumType" : null,
            "fluentSetterDocumentation" : "/**\n@param member \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "fluentSetterMethodName" : "withMember",
            "getterDocumentation" : "/**\n@return */",
            "getterMethodName" : "getMember",
            "getterModel" : {
              "returnType" : "GenericAttachment",
              "documentation" : null
            },
            "http" : {
              "additionalMarshallingPath" : null,
              "additionalUnmarshallingPath" : null,
              "flattened" : false,
              "greedy" : false,
              "header" : false,
              "isPayload" : false,
              "isStreaming" : false,
              "location" : null,
              "marshallLocation" : "PAYLOAD",
              "marshallLocationName" : "member",
              "queryString" : false,
              "statusCode" : false,
              "unmarshallLocationName" : "member",
              "uri" : false
            },
            "idempotencyToken" : false,
            "isBinary" : false,
            "list" : false,
            "listModel" : null,
            "map" : false,
            "mapModel" : null,
            "marshallingTargetClass" : "StructuredPojo",
            "marshallingType" : "STRUCTURED",
            "name" : "Member",
            "setterDocumentation" : "/**\n@param member */",
            "setterMethodName" : "setMember",
            "setterModel" : {
              "variableDeclarationType" : "GenericAttachment",
              "variableName" : "member",
              "variableType" : "GenericAttachment",
              "documentation" : "",
              "simpleType" : "GenericAttachment",
              "variableSetterType" : "GenericAttachment"
            },
            "simple" : false,
            "varargSetterDocumentation" : "/**\n@param member \n@return Returns a reference to this object so that method calls can be chained together.*/",
            "variable" : {
              "variableDeclarationType" : "GenericAttachment",
              "variableName" : "member",
              "variableType" : "GenericAttachment",
              "documentation" : "",
              "simpleType" : "GenericAttachment",
              "variableSetterType" : "GenericAttachment"
            },
            "xmlNameSpaceUri" : null
          },
          "memberLocationName" : null,
          "memberType" : "GenericAttachment",
          "map" : false,
          "marshallNonAutoConstructedEmptyLists" : false,
          "memberAdditionalMarshallingPath" : null,
          "memberAdditionalUnmarshallingPath" : null,
          "sendEmptyQueryString" : false,
          "simple" : false,
          "simpleType" : "GenericAttachment",
          "templateImplType" : "java.util.ArrayList<GenericAttachment>",
          "templateType" : "java.util.List<GenericAttachment>"
        },
        "map" : false,
        "mapModel" : null,
        "marshallingTargetClass" : "List",
        "marshallingType" : "LIST",
        "name" : "GenericAttachments",
        "setterDocumentation" : "/**<p>An array of attachment objects representing options.</p>\n@param genericAttachments An array of attachment objects representing options.*/",
        "setterMethodName" : "setGenericAttachments",
        "setterModel" : {
          "variableDeclarationType" : "java.util.List<GenericAttachment>",
          "variableName" : "genericAttachments",
          "variableType" : "java.util.List<GenericAttachment>",
          "documentation" : "",
          "simpleType" : "List<GenericAttachment>",
          "variableSetterType" : "java.util.Collection<GenericAttachment>"
        },
        "simple" : false,
        "varargSetterDocumentation" : "/**<p>An array of attachment objects representing options.</p>\n<p><b>NOTE:</b> This method appends the values to the existing list (if any). Use {@link #setGenericAttachments(java.util.Collection)} or {@link #withGenericAttachments(java.util.Collection)} if you want to override the existing values.</p>\n@param genericAttachments An array of attachment objects representing options.\n@return Returns a reference to this object so that method calls can be chained together.*/",
        "variable" : {
          "variableDeclarationType" : "java.util.List<GenericAttachment>",
          "variableName" : "genericAttachments",
          "variableType" : "java.util.List<GenericAttachment>",
          "documentation" : "<p>An array of attachment objects representing options.</p>",
          "simpleType" : "List<GenericAttachment>",
          "variableSetterType" : "java.util.Collection<GenericAttachment>"
        },
        "xmlNameSpaceUri" : null
      } ],
      "membersAsMap" : {
        "ContentType" : {
          "c2jName" : "contentType",
          "c2jShape" : "ContentType",
          "deprecated" : false,
          "documentation" : "<p>Content type of the response.</p>",
          "enumType" : "ContentType",
          "fluentSetterDocumentation" : "/**<p>Content type of the response.</p>\n@param contentType Content type of the response.\n@return Returns a reference to this object so that method calls can be chained together.\n@see ContentType*/",
          "fluentSetterMethodName" : "withContentType",
          "getterDocumentation" : "/**<p>Content type of the response.</p>\n@return Content type of the response.\n@see ContentType*/",
          "getterMethodName" : "getContentType",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "contentType",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "contentType",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "ContentType",
          "setterDocumentation" : "/**<p>Content type of the response.</p>\n@param contentType Content type of the response.\n@see ContentType*/",
          "setterMethodName" : "setContentType",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "contentType",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Content type of the response.</p>\n@param contentType Content type of the response.\n@return Returns a reference to this object so that method calls can be chained together.\n@see ContentType*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "contentType",
            "variableType" : "String",
            "documentation" : "<p>Content type of the response.</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        },
        "GenericAttachments" : {
          "c2jName" : "genericAttachments",
          "c2jShape" : "genericAttachmentList",
          "deprecated" : false,
          "documentation" : "<p>An array of attachment objects representing options.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>An array of attachment objects representing options.</p>\n@param genericAttachments An array of attachment objects representing options.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withGenericAttachments",
          "getterDocumentation" : "/**<p>An array of attachment objects representing options.</p>\n@return An array of attachment objects representing options.*/",
          "getterMethodName" : "getGenericAttachments",
          "getterModel" : {
            "returnType" : "java.util.List<GenericAttachment>",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "genericAttachments",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "genericAttachments",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : true,
          "listModel" : {
            "implType" : "java.util.ArrayList",
            "interfaceType" : "java.util.List",
            "listMemberModel" : {
              "c2jName" : "member",
              "c2jShape" : "GenericAttachment",
              "deprecated" : false,
              "documentation" : "",
              "enumType" : null,
              "fluentSetterDocumentation" : "/**\n@param member \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "fluentSetterMethodName" : "withMember",
              "getterDocumentation" : "/**\n@return */",
              "getterMethodName" : "getMember",
              "getterModel" : {
                "returnType" : "GenericAttachment",
                "documentation" : null
              },
              "http" : {
                "additionalMarshallingPath" : null,
                "additionalUnmarshallingPath" : null,
                "flattened" : false,
                "greedy" : false,
                "header" : false,
                "isPayload" : false,
                "isStreaming" : false,
                "location" : null,
                "marshallLocation" : "PAYLOAD",
                "marshallLocationName" : "member",
                "queryString" : false,
                "statusCode" : false,
                "unmarshallLocationName" : "member",
                "uri" : false
              },
              "idempotencyToken" : false,
              "isBinary" : false,
              "list" : false,
              "listModel" : null,
              "map" : false,
              "mapModel" : null,
              "marshallingTargetClass" : "StructuredPojo",
              "marshallingType" : "STRUCTURED",
              "name" : "Member",
              "setterDocumentation" : "/**\n@param member */",
              "setterMethodName" : "setMember",
              "setterModel" : {
                "variableDeclarationType" : "GenericAttachment",
                "variableName" : "member",
                "variableType" : "GenericAttachment",
                "documentation" : "",
                "simpleType" : "GenericAttachment",
                "variableSetterType" : "GenericAttachment"
              },
              "simple" : false,
              "varargSetterDocumentation" : "/**\n@param member \n@return Returns a reference to this object so that method calls can be chained together.*/",
              "variable" : {
                "variableDeclarationType" : "GenericAttachment",
                "variableName" : "member",
                "variableType" : "GenericAttachment",
                "documentation" : "",
                "simpleType" : "GenericAttachment",
                "variableSetterType" : "GenericAttachment"
              },
              "xmlNameSpaceUri" : null
            },
            "memberLocationName" : null,
            "memberType" : "GenericAttachment",
            "map" : false,
            "marshallNonAutoConstructedEmptyLists" : false,
            "memberAdditionalMarshallingPath" : null,
            "memberAdditionalUnmarshallingPath" : null,
            "sendEmptyQueryString" : false,
            "simple" : false,
            "simpleType" : "GenericAttachment",
            "templateImplType" : "java.util.ArrayList<GenericAttachment>",
            "templateType" : "java.util.List<GenericAttachment>"
          },
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "List",
          "marshallingType" : "LIST",
          "name" : "GenericAttachments",
          "setterDocumentation" : "/**<p>An array of attachment objects representing options.</p>\n@param genericAttachments An array of attachment objects representing options.*/",
          "setterMethodName" : "setGenericAttachments",
          "setterModel" : {
            "variableDeclarationType" : "java.util.List<GenericAttachment>",
            "variableName" : "genericAttachments",
            "variableType" : "java.util.List<GenericAttachment>",
            "documentation" : "",
            "simpleType" : "List<GenericAttachment>",
            "variableSetterType" : "java.util.Collection<GenericAttachment>"
          },
          "simple" : false,
          "varargSetterDocumentation" : "/**<p>An array of attachment objects representing options.</p>\n<p><b>NOTE:</b> This method appends the values to the existing list (if any). Use {@link #setGenericAttachments(java.util.Collection)} or {@link #withGenericAttachments(java.util.Collection)} if you want to override the existing values.</p>\n@param genericAttachments An array of attachment objects representing options.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "java.util.List<GenericAttachment>",
            "variableName" : "genericAttachments",
            "variableType" : "java.util.List<GenericAttachment>",
            "documentation" : "<p>An array of attachment objects representing options.</p>",
            "simpleType" : "List<GenericAttachment>",
            "variableSetterType" : "java.util.Collection<GenericAttachment>"
          },
          "xmlNameSpaceUri" : null
        },
        "Version" : {
          "c2jName" : "version",
          "c2jShape" : "String",
          "deprecated" : false,
          "documentation" : "<p>Version of response card format.</p>",
          "enumType" : null,
          "fluentSetterDocumentation" : "/**<p>Version of response card format.</p>\n@param version Version of response card format.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "fluentSetterMethodName" : "withVersion",
          "getterDocumentation" : "/**<p>Version of response card format.</p>\n@return Version of response card format.*/",
          "getterMethodName" : "getVersion",
          "getterModel" : {
            "returnType" : "String",
            "documentation" : null
          },
          "http" : {
            "additionalMarshallingPath" : null,
            "additionalUnmarshallingPath" : null,
            "flattened" : false,
            "greedy" : false,
            "header" : false,
            "isPayload" : false,
            "isStreaming" : false,
            "location" : null,
            "marshallLocation" : "PAYLOAD",
            "marshallLocationName" : "version",
            "queryString" : false,
            "statusCode" : false,
            "unmarshallLocationName" : "version",
            "uri" : false
          },
          "idempotencyToken" : false,
          "isBinary" : false,
          "list" : false,
          "listModel" : null,
          "map" : false,
          "mapModel" : null,
          "marshallingTargetClass" : "String",
          "marshallingType" : "STRING",
          "name" : "Version",
          "setterDocumentation" : "/**<p>Version of response card format.</p>\n@param version Version of response card format.*/",
          "setterMethodName" : "setVersion",
          "setterModel" : {
            "variableDeclarationType" : "String",
            "variableName" : "version",
            "variableType" : "String",
            "documentation" : "",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "simple" : true,
          "varargSetterDocumentation" : "/**<p>Version of response card format.</p>\n@param version Version of response card format.\n@return Returns a reference to this object so that method calls can be chained together.*/",
          "variable" : {
            "variableDeclarationType" : "String",
            "variableName" : "version",
            "variableType" : "String",
            "documentation" : "<p>Version of response card format.</p>",
            "simpleType" : "String",
            "variableSetterType" : "String"
          },
          "xmlNameSpaceUri" : null
        }
      },
      "requestSignerAware" : false,
      "requestSignerClassFqcn" : null,
      "required" : null,
      "shapeName" : "ResponseCard",
      "unmarshaller" : {
        "flattened" : false,
        "resultWrapper" : null
      },
      "variable" : {
        "variableDeclarationType" : "ResponseCard",
        "variableName" : "responseCard",
        "variableType" : "ResponseCard",
        "documentation" : null,
        "simpleType" : "ResponseCard",
        "variableSetterType" : "ResponseCard"
      },
      "wrapper" : false
    }
  },
  "clientConfigFactory" : "ClientConfigurationFactory",
  "customAuthorizers" : { },
  "examples" : {
    "examples" : { },
    "version" : "1.0"
  },
  "exceptionUnmarshallerImpl" : null,
  "fileHeader" : "/*\n * Copyright 2012-2017 Amazon.com, Inc. or its affiliates. All Rights\n * Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */",
  "hasWaiters" : false,
  "sdkBaseResponseFqcn" : "com.amazonaws.AmazonWebServiceResult<com.amazonaws.ResponseMetadata>",
  "sdkModeledExceptionBaseClassName" : "AmazonLexRuntimeException",
  "sdkModeledExceptionBaseFqcn" : "com.amazonaws.services.lexruntime.model.AmazonLexRuntimeException",
  "serviceBaseExceptionFqcn" : "com.amazonaws.AmazonServiceException",
  "transformPackage" : "com.amazonaws.services.lexruntime.model.transform"
}